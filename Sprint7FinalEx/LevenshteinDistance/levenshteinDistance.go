/**
id в контесте 65529751
-- ПРИНЦИП РАБОТЫ --
Привет! Опять не смог решить задачу быстро, в итоге когда я решил прочитать на википедии про это расстояние Левенштейна, там же и увидел ответ:(
Поэтому по сути это решение отсюда https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0
Обидно, на самом деле, я был очень близко к ответу, у меня в разных вариантах был и dp[i - 1][g] + 1, и dp[i][g-1] + 1, и dp[i - 1][g - 1] + 1, но почему-то
совместить их я не додумался:(
Я использовал двумерную динамику. Опишу алгоритм как в теории:
1. Что будет храниться в матрице dp?
	В матрице dp будет храниться то, сколько нужно преобразований префикса строки s[0:i] для того, чтобы получить префикс строки m[0:g]
2. Каким будет базовый случай для задачи?
	То сколько нужно преобразований для пустых строк. Для пустой строки s и пустой строки m нужно 0 преобразований. Для строки s длинной 1 и
	пустой строки m нужно 1 преобразование и т.д.
3. Каким будет переход динамики?
	Если s[i] == m[g] то мы просто берем то, сколько нужно преобразований префикса s[0:i - 1] для получения m[0:g - 1]


	Если нет, то мы выбираем минимальное значение из 3:
	Сколько нужно преобразований префикса s[0:i - 1] для получения m[0:g] + 1, что, по сути, является удалением s[i],
	Сколько нужно преобразований префикса m[0:g - 1] для получения s[0:i] + 1, что, по сути, является удалением m[g],
	Сколько нужно преобразований префикса s[0:i - 1] для получения m[0:g - 1] + 1, что, по сути, является заменой m[g] на s[i]

	Если s[i] != m[g], то при любом раскладе у нас будет +1,

	Грубо говоря, если s[i] == m[g] то мы берем значение из предыдущих подстрок, не прибавляя ничего, если  s[i] != m[g], то мы делаем +1

4. Каким будет порядок вычисления данных в массиве dp?
	Используя Динамическое программирование назад, смотря предыдущие значения, изначально исходя из базового случая
5. Где будет располагаться ответ на исходный вопрос?
	В матрице dp[len(s)][len(m)]

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Даже не знаю что тут написать:) По сути, корректность доказывает базовый случай и переход динамики.
Если представить, что у нас есть строки abac и acab то базовый случай будет таким:
     a c a b
  [0 1 2 3 4]
a [1 0 0 0 0]
b [2 0 0 0 0]
a [3 0 0 0 0]
c [4 0 0 0 0]

По сути самое важное в корректной работе алгоритма, это то, что если символы равны, мы берем dp[i-1][g-1], то есть результат без последнего символа
обеих строк

Опираясь на переход динамики, первая итерация даст нам такой результат:
     a c a b
  [0 1 2 3 4]
a [1 0 1 2 3]
b [2 0 0 0 0]
a [3 0 0 0 0]
c [4 0 0 0 0]

В итоге мы получим такой результат:

     a c a b
  [0 1 2 3 4]
a [1 0 1 2 3]
b [2 1 1 2 2]
a [3 2 2 1 2]
c [4 3 2 2 2]
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Обычная двумерная динамика O(len(s) * len(m))
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы храним обе строки + матрицу размером len(s) на len(m), в итоге получаем O(len(s) + len(m) + len(s) * len(m))

*/

package levenshteinDistance

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

type Matrix [][]int

func (m Matrix) String(si, mi string) string {
	s := ""
	s += "     " + fmt.Sprint(strings.Join(strings.Split(mi, ""), " "))
	s += string('\n')
	for i, ints := range m {
		if i > 0 {
			s += string(si[i-1]) + " "
		} else {
			s += "  "
		}
		s += fmt.Sprint(ints)
		s += string('\n')
	}
	return s
}

func LevenshteinDistance(r io.Reader, w io.Writer) {
	scanner := bufio.NewScanner(r)
	scanner.Scan()
	s := scanner.Text()
	scanner.Scan()
	m := scanner.Text()
	dp := make(Matrix, len(s)+1)
	for i := 0; i < len(s)+1; i++ {
		dp[i] = make([]int, len(m)+1)
		if i == 0 {
			for g := 0; g < len(m)+1; g++ {
				dp[i][g] = g
			}
			continue
		}

		for g := 0; g < len(m)+1; g++ {
			if g == 0 {
				dp[i][g] = i
				continue
			}
			if s[i-1] == m[g-1] {
				dp[i][g] = dp[i-1][g-1]
			} else {
				dp[i][g] = minOfThree(dp[i-1][g]+1, dp[i][g-1]+1, dp[i-1][g-1]+1)
			}
		}
	}
	//fmt.Println(dp.String(s, m))
	writer := bufio.NewWriter(w)
	writer.WriteString(strconv.Itoa(dp[len(s)][len(m)]))
	writer.Flush()
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func minOfThree(a, b, c int) int {
	abMin := minOfTwo(a, b)
	return minOfTwo(abMin, c)
}

func minOfTwo(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	LevenshteinDistance(os.Stdin, os.Stdout)
}
